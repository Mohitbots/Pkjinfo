---
title: "Getting Started with Next.js 14 App Router"
description: "Learn everything you need to know about Next.js 14 and the new App Router, including Server Components, layouts, and best practices."
date: "2024-12-01"
lastUpdated: "2024-12-03"
author: "Your Name"
image: "/images/blog/nextjs-14-guide.jpg"
tags: ["nextjs", "react", "web-development", "tutorial"]
category: "Tutorial"
featured: true
draft: false
---

## Introduction

Next.js 14 represents a significant milestone in React development, introducing powerful features that make building modern web applications easier and more efficient than ever before. In this comprehensive guide, we'll explore everything you need to know to get started with Next.js 14 and the App Router.

## What's New in Next.js 14?

Next.js 14 brings several exciting improvements:

- **Turbopack**: A new bundler that's up to 700x faster than Webpack
- **Server Actions**: Simplified data mutations without API routes
- **Partial Prerendering**: Combining static and dynamic rendering
- **Improved TypeScript Support**: Better type inference and error messages

## Understanding the App Router

The App Router is a paradigm shift in how we build Next.js applications. Unlike the traditional Pages Router, it leverages React Server Components to provide better performance and developer experience.

### Key Concepts

#### Server Components

By default, all components in the App Router are Server Components. This means they:

- Run only on the server
- Have zero JavaScript bundle size
- Can directly access backend resources
- Support async/await natively

Here's a simple example:

```tsx
// app/page.tsx
async function HomePage() {
  const data = await fetch('https://api.example.com/data');
  const posts = await data.json();

  return (
    <div>
      <h1>My Blog Posts</h1>
      {posts.map((post) => (
        <article key={post.id}>
          <h2>{post.title}</h2>
          <p>{post.excerpt}</p>
        </article>
      ))}
    </div>
  );
}

export default HomePage;
```

#### Client Components

When you need interactivity, use Client Components:

```tsx
'use client';

import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}
```

## Setting Up Your First Project

Let's create a new Next.js 14 project:

```bash
npx create-next-app@latest my-app
cd my-app
npm run dev
```

The setup wizard will ask you several questions:

- TypeScript? **Yes**
- ESLint? **Yes**
- Tailwind CSS? **Yes**
- App Router? **Yes**
- Import alias? **@/***

## Project Structure

Your new project will have this structure:

```
my-app/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ layout.tsx      # Root layout
â”‚   â”œâ”€â”€ page.tsx        # Home page
â”‚   â””â”€â”€ globals.css     # Global styles
â”œâ”€â”€ public/             # Static files
â”œâ”€â”€ next.config.js      # Configuration
â””â”€â”€ package.json
```

## Layouts and Templates

Layouts are one of the most powerful features of the App Router. They wrap multiple pages and maintain state across navigation.

### Root Layout

Every app needs a root layout:

```tsx
// app/layout.tsx
export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <nav>My Navigation</nav>
        {children}
        <footer>My Footer</footer>
      </body>
    </html>
  );
}
```

### Nested Layouts

You can create nested layouts for specific sections:

```tsx
// app/blog/layout.tsx
export default function BlogLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="blog-container">
      <aside>Blog Sidebar</aside>
      <main>{children}</main>
    </div>
  );
}
```

## Dynamic Routes

Create dynamic routes using folder names in brackets:

```
app/
â””â”€â”€ blog/
    â””â”€â”€ [slug]/
        â””â”€â”€ page.tsx
```

```tsx
// app/blog/[slug]/page.tsx
export default function BlogPost({
  params,
}: {
  params: { slug: string };
}) {
  return <h1>Post: {params.slug}</h1>;
}

// Generate static params at build time
export async function generateStaticParams() {
  const posts = await getPosts();
  
  return posts.map((post) => ({
    slug: post.slug,
  }));
}
```

## Data Fetching

Next.js 14 makes data fetching incredibly simple with async Server Components:

```tsx
async function getData() {
  const res = await fetch('https://api.example.com/data', {
    next: { revalidate: 3600 }, // Revalidate every hour
  });
  
  if (!res.ok) {
    throw new Error('Failed to fetch data');
  }
  
  return res.json();
}

async function Page() {
  const data = await getData();
  
  return <div>{/* Render data */}</div>;
}
```

## Metadata and SEO

Next.js 14 provides excellent SEO support through metadata:

```tsx
// app/blog/[slug]/page.tsx
import { Metadata } from 'next';

export async function generateMetadata({
  params,
}: {
  params: { slug: string };
}): Promise<Metadata> {
  const post = await getPost(params.slug);
  
  return {
    title: post.title,
    description: post.excerpt,
    openGraph: {
      title: post.title,
      description: post.excerpt,
      images: [post.image],
    },
  };
}
```

## Best Practices

### 1. Use Server Components by Default

Only use Client Components when you need:
- Event listeners
- Browser APIs
- React hooks
- State management

### 2. Optimize Images

Always use the Next.js Image component:

```tsx
import Image from 'next/image';

<Image
  src="/hero.jpg"
  alt="Hero image"
  width={1200}
  height={600}
  priority
/>
```

### 3. Implement Loading States

Use loading.tsx for automatic loading UI:

```tsx
// app/blog/loading.tsx
export default function Loading() {
  return <div>Loading posts...</div>;
}
```

### 4. Error Handling

Create error.tsx for error boundaries:

```tsx
// app/error.tsx
'use client';

export default function Error({
  error,
  reset,
}: {
  error: Error;
  reset: () => void;
}) {
  return (
    <div>
      <h2>Something went wrong!</h2>
      <button onClick={reset}>Try again</button>
    </div>
  );
}
```

## Performance Optimization

Next.js 14 includes several built-in optimizations:

1. **Automatic Code Splitting**: Each route only loads necessary code
2. **Image Optimization**: Automatic WebP/AVIF conversion
3. **Font Optimization**: Next.js automatically optimizes fonts
4. **Prefetching**: Links are prefetched in the viewport

## Conclusion

Next.js 14 with the App Router is a game-changer for React developers. Its Server Components, improved routing, and excellent developer experience make it the perfect choice for building modern web applications.

Start small, experiment with the features, and gradually migrate your existing projects. The future of React development is here, and it's incredibly exciting!

## Resources

- [Next.js Documentation](https://nextjs.org/docs)
- [React Documentation](https://react.dev)
- [Vercel Blog](https://vercel.com/blog)

Happy coding! ðŸš€
